<html>
<head>
<title>RainbowForth</title>
</head>
<body>


<table align="center" bgcolor="#000000"
       border="0" cellpadding="0" cellspacing="0">
<tr border="0" cellpadding="0" cellspacing="0">
<td border="0" cellpadding="0" cellspacing="0">
<b><font size="7">
<pre id="console">
</pre>
</font></b>
</td></tr></table>


<script type="text/javascript">

// -----------------------------------------------------------------

var HTTP = {};

HTTP._factories = [
  function() { return new XMLHttpRequest(); },
  function() { return new ActiveXObject('Msxml2.XMLHTTP'); },
  function() { return new ActiveXObject('Microsoft.XMLHTTP'); },
];

HTTP._factory = null;

HTTP.newRequest = function() {
  if (HTTP._factory != null) return HTTP._factory();
  for(var i = 0; i < HTTP._factories.length; i++) {
    try {
      var factory = HTTP._factories[i];
      var request = factory();
      if (request != null) {
        HTTP._factory = factory;
        return request;
      }
    } catch(e) {
      continue;
    }
  }
  HTTP._factory = function() {
    throw new Error('XMLHttpRequest not supported');
  }
  HTTP._factory();
};

HTTP.encodeFormData = function(data) {
  var pairs = [];
  var regexp = /%20/g;

  for (var name in data) {
    var value = data[name].toString();
    var pair = encodeURIComponent(name).replace(regexp, '+') + '=' +
               encodeURIComponent(value).replace(regexp, '+');
    pairs.push(pair);
  }

  return pairs.join('&');
};

HTTP.post = function(url, values, callback, errorHandler) {
  var request = HTTP.newRequest();
  request.onreadystatechange = function() {
    if (request.readyState == 4) {
      if (request.status == 200) {
        callback(request.responseText);
      } else {
        if (errorHandler != null) {
          errorHandler(request.status, request.statusText);
        } else {
          callback(null);
        }
      }
    }
  };
  request.open('POST', url);
  request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
  request.send(HTTP.encodeFormData(values));
};

HTTP.getText = function(url, callback) {
  var request = HTTP.newRequest();
  request.onreadystatechange = function() {
    if (request.readyState == 4) {
      if (request.status == 200) {
        callback(request.responseText);
      } else {
        callback(null);
      }
    }
  }
  request.open('GET', url);
  request.send(null);
};


// -----------------------------------------------------------------


var CONSOLE_WIDTH = 64;
var CONSOLE_HEIGHT = 18;

var console = new Array();

function setupConsole() {
  for (var y=0;y<CONSOLE_HEIGHT;y++) {
    for (var x=0;x<CONSOLE_WIDTH;x++) {
      var element=document.createElement('font');
      element.appendChild(document.createTextNode(' '))
      document.getElementById('console').appendChild(element);
      console[x+y*CONSOLE_WIDTH]=element;
    }
    var element=document.createElement('br')
    document.getElementById('console').appendChild(element);
  }
}

function numberToColor(n) {
  var col = ("00000" + n.toString(16));
  col = col.substr(col.length - 6, 6);
  return "#" + col;
}

function consolePlot(x, y, text, fg, bg) {
  var element = console[x+y*CONSOLE_WIDTH];
  element.firstChild.nodeValue = String.fromCharCode(text);
  element.setAttribute("color", numberToColor(fg));
  element.setAttribute("style", "background-color: " + numberToColor(bg));
}

function consoleClear(fg, bg) {
  for (var j = 0; j < CONSOLE_HEIGHT; j++) {
    for (var i = 0; i < CONSOLE_WIDTH; i++) {
      consolePlot(i, j, 32, fg, bg);
    }
  }
}

function consoleEmit(c, ch) {
  if(ch == 13) {
    c.console_x = 0;
    c.console_y++;
    if (c.console_y == CONSOLE_HEIGHT) {
      c.console_y--;
    }
  } else {
    consolePlot(c.console_x, c.console_y, ch,
                c.foreground, c.background);
    c.console_x++;
    if (c.console_x == CONSOLE_WIDTH) {
      c.console_y++;
      if (c.console_y == CONSOLE_HEIGHT) {
        c.console_y--;
      }
    }
  }
}

function consoleEmitString(c, str) {
  for (var i = 0; i < str.length; i++) {
    consoleEmit(c, str.charCodeAt(i));
  }
}


// -----------------------------------------------------------------


var heap = new Array();


// -----------------------------------------------------------------


var threads = new Array();

function ThreadContext() {
  this.ip = 0;
  this.dstack = new Array();
  this.rstack = new Array();
  this.foreground = 0xffffff;
  this.background = 0x000000;
  this.console_x = 0;
  this.console_y = 0;
  this.yield = 0;
}

ThreadContext.prototype.run = function() {
  do {
    heap[this.ip++](this);
  } while(!this.yield);
}

function runAll() {
  var runSet = threads.slice();
  for (var i = 0; i < runSet.length; i++) {
    runSet[i].run();
  }
}

function createThread(ip, value) {
  var c = new ThreadContext();
  c.ip = ip;
  c.dstack.push(value);
  threads.push(c);
}

function dropThread(c) {
  for (var i = 0; i < threads.length; i++) {
    if (threads[i] == c) {
      threads[i] = threads[threads.length - 1];
      threads.pop();
      break;
    }
  }
}


// -----------------------------------------------------------------


var keyBuffer = [];

function setupEvents() {
  document.onkeydown = function(e) {
    var e = window.event || e;
    keyBuffer.unshift(-e.keyCode);
    runAll();
  }
  document.onkeypress = function(e) {
    var e = window.event || e;
    keyBuffer.unshift(e.keyCode);
    runAll();
  }
}


// -----------------------------------------------------------------

var RED_SPACE = String.fromCharCode(255);
var YELLOW_SPACE = String.fromCharCode(254);
var GREEN_SPACE = String.fromCharCode(253);
var CYAN_SPACE = String.fromCharCode(252);
var BLUE_SPACE = String.fromCharCode(251);
var MAGENTA_SPACE = String.fromCharCode(250);
var WHITE_SPACE = ' ';
var ALL_SPACES = RED_SPACE + YELLOW_SPACE + GREEN_SPACE + CYAN_SPACE +
                 BLUE_SPACE + MAGENTA_SPACE + WHITE_SPACE;

// -----------------------------------------------------------------


function literal(n) {
  return function(c) {
    c.dstack.push(n);
  };
}

function call_addr(n) {
  return function(c) {
    c.rstack.push(c.ip);
    c.ip = n;
  };
}

function jump_addr(n) {
  return function(c) {
    c.ip = n;
  };
}

var macro_mode = false;
var dictionary_macro = {};

var dictionary = {
  'allot': function(c) {
    var sz = c.dstack.pop();
    while(sz--) {
      heap.push(0);
    }
  },
  ',': function(c) {
    heap.push(c.dstack.pop());
  },
  'literal': function(c) {
    var n = c.dstack.pop();
    heap.push(literal(n));
  },
  'raw-compile,': function(c) {
    var n = c.dstack.pop();
    heap.push(call_addr(n));
  },
  ';': function(c) {
    c.ip = c.rstack.pop();
  },
  'macro': function(c) {
    macro_mode = true;
  },
  'forth': function(c) {
    macro_mode = false;
  },
  'swap': function(c) {
    var tmp1 = c.dstack.pop();
    var tmp2 = c.dstack.pop();
    c.dstack.push(tmp1);
    c.dstack.push(tmp2);
  },
  'drop': function(c) {
    c.dstack.pop();
  },
  'over': function(c) {
    c.dstack.push(c.dstack[c.dstack.length - 2]);
  },
  'dup': function(c) {
    c.dstack.push(c.dstack[c.dstack.length - 1]);
  },
  'push': function(c) {
    c.rstack.push(c.dstack.pop());
  },
  'pop': function(c) {
    c.dstack.push(c.rstack.pop());
  },
  'i': function(c) {
    c.dstack.push(c.rstack.back());
  },
  '+': function(c) {
    c.dstack.push(c.dstack.pop() + c.dstack.pop());
  },
  '-': function(c) {
    var tmp = c.dstack.pop();
    c.dstack.push(c.dstack.pop() - tmp);
  },
  '*': function(c) {
    c.dstack.push(c.dstack.pop() * c.dstack.pop());
  },
  'min': function(c) {
    var a = c.dstack.pop();
    var b = c.dstack.pop();
    if (a < b) { c.dstack.push(a); } else { c.dstack.push(b); }
  },
  'max': function(c) {
    var a = c.dstack.pop();
    var b = c.dstack.pop();
    if (a > b) { c.dstack.push(a); } else { c.dstack.push(b); }
  },
  'negate': function(c) { c.dstack.push(-c.dstack.pop()); },
  'not': function(c) { c.dstack.push(!c.dstack.pop()); },
  'and': function(c) { c.dstack.push(c.dstack.pop() & c.dstack.pop()); },
  'or': function(c) { c.dstack.push(c.dstack.pop() | c.dstack.pop()); },
  'xor': function(c) { c.dstack.push(c.dstack.pop() ^ c.dstack.pop()); },
  '=': function(c) { c.dstack.push(c.dstack.pop() == c.dstack.pop()); },
  '<>': function(c) { c.dstack.push(c.dstack.pop() != c.dstack.pop()); },
  '<': function(c) { c.dstack.push(c.dstack.pop() > c.dstack.pop()); },
  '>': function(c) { c.dstack.push(c.dstack.pop() < c.dstack.pop()); },
  '<=': function(c) { c.dstack.push(c.dstack.pop() >= c.dstack.pop()); },
  '>=': function(c) { c.dstack.push(c.dstack.pop() <= c.dstack.pop()); },
  'ifskip': function(c) {
    if (c.dstack.pop()) {
      c.ip++;
    }
  },
  'jump!': function(c) {
    var addr = c.dstack.pop();
    var towhere = c.dstack.pop();
    heap[addr] = jump_addr(towhere);
  },
  'here': function(c) {
    c.dstack.push(heap.length);
  },
  '!': function(c) {
    var addr = c.dstack.pop();
    var val = c.dstack.pop();
    heap[addr] = val;
  },
  '@': function(c) {
    c.dstack.push(heap[c.dstack.pop()]);
  },
  '+!': function(c) {
    var addr = c.dstack.pop();
    heap[addr] += c.dstack.pop();
  },
  'fill': function(c) {
    var ch = c.dstack.pop();
    var count = c.dstack.pop();
    var addr = c.dstack.pop();
    for (var i = 0; i < count; i++) {
      heap[addr + i] = ch;
    }
  },
  'random': function(c) {
    var high = c.dstack.pop();
    var low = c.dstack.pop();
    var pick = Math.floor(Math.random() * (high - low + 1)) + low;
    c.dstack.push(pick);
  },
  'foreground': function(c) {
    c.foreground = c.dstack.pop();
  },
  'background': function(c) {
    c.background = c.dstack.pop();
  },
  'setraw': function(c) {
    var pos = c.dstack.pop();
    c.console_y = Math.floor(pos / CONSOLE_WIDTH);
    c.console_x = pos % CONSOLE_WIDTH;
  },
  'setxy': function(c) {
    c.console_y = c.dstack.pop();
    c.console_x = c.dstack.pop();
  },
  'sizexy': function(c) {
    c.dstack.push(CONSOLE_WIDTH);
    c.dstack.push(CONSOLE_HEIGHT);
  },
  'emit': function(c) {
    var ch = c.dstack.pop();
    if (ch == 0) { ch = 32; }
    consoleEmit(c, ch);
  },
  '.': function(c) {
    var number = String(c.dstack.pop());
    consoleEmitString(c, number);
  },
  'alert': function(c) {
    alert(c.dstack.pop());
  },
  'cls': function(c) {
    consoleClear(c.foreground, c.background);
    c.console_x = 0;
    c.console_y = 0;
  },
  'key': function(c) {
    if (keyBuffer.length == 0) {
      c.yield = 1;
      c.ip--;
    } else {
      c.yield = 0;
      c.dstack.push(keyBuffer.pop());
    }
  },
  'read': function(c) {
    if (c.yield) {
      c.ip--;
      return;
    }
    var addr = c.dstack.pop();
    var block = c.dstack.pop();
    HTTP.post('/read', {'index': String(block)},
              function(result) {
                if (result == null) {
                  alert('READ FAILED!');
                  return;
                }
                for (var i = 0; i < 1024; i++) {
                  heap[addr + i] = result.charCodeAt(i);
                }
                c.yield = 0;
                c.ip++;
                runAll();
              }, null);
    c.yield = 1;
    c.ip--;
  },
  'write': function(c) {
    if (c.yield) {
      c.ip--;
      return;
    }
    var addr = c.dstack.pop();
    var block = c.dstack.pop();
    var dt = '';
    for (var i = 0; i < 1024; i++) {
      dt += String.fromCharCode(heap[addr + i]);
    }
    HTTP.post('/write', {'index': String(block),
                         'data': dt},
              function(result) {
                c.yield = 0;
                c.ip++;
                runAll();
              }, null);
    c.yield = 1;
    c.ip--;
  },
  'fork': function(c) {
    createThread(c.ip, 1);
    c.dstack.push(0);
  },
  'terminate': function(c) {
    c.yield = 1;
    dropThread(c);
  },
  'raw-load': function(c) {
    var text = c.rstack.pop();
    var word = '';
    for(var i = 0; i < text.length; i++) {
      var ch = text[i];
      if (ALL_SPACES.indexOf(ch) >= 0) {
        if (!word.length) continue;
        if (ch == WHITE_SPACE) {
          // White - Skip comments.
        } else if (ch == RED_SPACE) {
          // Red - Define a word.
          dictionary[word] = call_addr(heap.length);
          dictionary_macro[word] = macro_mode;
        } else if (ch == YELLOW_SPACE) {
          // Yellow - Execute a word or push a literal.
          if (dictionary[word] != undefined) {
            c.ip--;
            c.rstack.push(text.substr(i));
            dictionary[word](c);
            return;
          } else if (word[word.length-1] == 'h') {
            c.dstack.push(parseInt(word, 16));
          } else {
            c.dstack.push(parseInt(word));
          }
        } else if (ch == GREEN_SPACE) {
          // Green - Compile a word (unless macro) or compile a literal.
          if (dictionary[word] != undefined) {
            if (dictionary_macro[word]) {
              c.ip--;
              c.rstack.push(text.substr(i));
              dictionary[word](c);
              return;
            } else {
              heap.push(dictionary[word]);
            }
          } else if (word[word.length-1] == 'h') {
            heap.push(literal(parseInt(word, 16)));
          } else {
            heap.push(literal(parseInt(word)));
          }
        } else if (ch == CYAN_SPACE) {
          // Cyan - Compile a word (including macros) or compile a literal.
          if (dictionary[word] != undefined) {
            heap.push(dictionary[word]);
          } else if (word[word.length-1] == 'h') {
            heap.push(literal(parseInt(word, 16)));
          } else {
            heap.push(literal(parseInt(word)));
          }
        } else if (ch == BLUE_SPACE) {
          // Blue - Push xt for word on stack.
          c.dstack.push(dictionary[word]);
        } else if (ch == MAGENTA_SPACE) {
          // Magenta - define a variable.
          dictionary[word] = literal(heap.length);
          heap.push(0);
        }
        word = '';
      } else {
        word += ch;
      }
    }
  }
  // IE can't handle trailing commas here.
};


// -----------------------------------------------------------------

function PlainToColor(text) {
  var color = GREEN_SPACE;
  var ret = '';
  var word = '';
  for (var i = 0; i < text.length ; i++) {
    var ch = text[i];
    if (ch == ' ') {
      if (!word.length) continue;
      if (word == '(') {
        color = WHITE_SPACE;
      } else if (word == '[') {
        color = YELLOW_SPACE;
      } else if (word == '{') {
        color = CYAN_SPACE;
      } else if (word == ')' || word == ']' || word == '}') {
        color = GREEN_SPACE;
      } else if (word == ':') {
        color = RED_SPACE;
      } else if (word == "'") {
        color = BLUE_SPACE;
      } else if (word == '') {
        color = CYAN_SPACE;
      } else if (word == 'variable') {
        color = MAGENTA_SPACE;
      } else {
        ret += word;
        ret += color;
        if (color == RED_SPACE || color == CYAN_SPACE ||
            color == BLUE_SPACE || color == MAGENTA_SPACE) {
          color = GREEN_SPACE;
        }
      }
      word = '';
    } else {
      word += ch;
    }
  }
  return ret;
}

// -----------------------------------------------------------------

var bootstrap = PlainToColor(
" : nip   swap drop ; " +
" : width   sizexy drop ; " +
" : height   sizexy nip 2 - ; " +
" : ifskip,   ' ifskip [ literal ] , ; " +
" : jump-later,   here 0 literal ; " +
" [ macro ] " +
" : if   ifskip, jump-later, ; " +
" : then   here swap jump! ; " +
" : else    jump-later,  swap  { then } ; " +
" : begin   here ; " +
" : while   ifskip, jump-later, ; " +
" : repeat   swap  jump-later, jump!  { then } ; " +
" : until   ifskip,  jump-later, jump! ; " +
" : again   jump-later, jump! ; " +
" [ forth ] " +
" : color-ch " +
"      dup 255 = if ff0000h foreground then " +
"      dup 254 = if ffff00h foreground then " +
"      dup 253 = if 00ff00h foreground then " +
"      dup 252 = if 00ffffh foreground then " +
"      dup 251 = if 0000ffh foreground then " +
"      dup 250 = if ff00ffh foreground then " +
"      dup 32  = if ffffffh foreground then " +
"      dup 250 >= if drop 32 emit else emit then ; " +
" variable cursor-pos " +
" variable cursor-block " +
" variable cursor-color [ 32 cursor-color ! ] " +
" variable edit-buffer [ here 1024 allot edit-buffer ! ] " +
" : clip-cursor  cursor-pos @  0 max  width height * 1 - min  cursor-pos ! ; " +
" : handle-cursor " +
"      cursor-pos @ = if 777777h background else 0 background then ; " +
" : redraw-one   dup handle-cursor dup setraw edit-buffer @ + @ color-ch ; " +
" : blanks    begin 0 > while 32 emit 1 - repeat drop ; " +
" : show-page   0 17 setxy ffffffh foreground " +
"                          0 background cursor-block @ . 10 blanks ; " +
" : redraw   1024 begin dup 0 > while 1 - dup redraw-one repeat drop ; " +
" : redraw-all   redraw show-page ; " +
" : type-one   edit-buffer @ cursor-pos @ + !   1 cursor-pos +! ; " +
" : editor-save   cursor-block @ edit-buffer @ write ; " +
" : editor-load   cursor-block @ edit-buffer @ read ; " +
" : special-mode    begin key " +
"      dup 114 = if 255 cursor-color ! ; then " +
"      dup 121 = if 254 cursor-color ! ; then " +
"      dup 103 = if 253 cursor-color ! ; then " +
"      dup 99 = if 252 cursor-color ! ; then " +
"      dup 98 = if 251 cursor-color ! ; then " +
"      dup 109 = if 250 cursor-color ! ; then " +
"      dup 119 = if 32 cursor-color ! ; then " +
"      dup 39 = if 39 type-one ; then " +
"      clip-cursor " +
"      redraw-all drop again ; " +
" : edit-mode    begin key " +
"      dup -37 = if -1 cursor-pos +! then " +
"      dup -39 = if 1 cursor-pos +! then " +
"      dup -38 = if width negate cursor-pos +! then " +
"      dup -40 = if width cursor-pos +! then " +
"      dup -33 = if cursor-block @ 0 > if " +
"          editor-save -1 cursor-block +! editor-load then then " +
"      dup -34 = if editor-save 1 cursor-block +! editor-load then " +
"      dup 39 = if special-mode else " +
"         dup 33 >= if dup 126 <= if type-one then then then " +
"      dup 32 = if cursor-color @ type-one then " +
"      clip-cursor " +
"      redraw-all drop again ; " +
" : main   redraw-all edit-mode ; " +
" [ main ] " +
" ");

// -----------------------------------------------------------------


function afterLoad(result) {
  consoleClear(0, 0);
  heap.push(literal(bootstrap));
  heap.push(dictionary.push);
  heap.push(dictionary['raw-load']);
  heap.push(dictionary.terminate);
  createThread(0, 0);
  runAll();
}

function main() {
  setupConsole();
  setupEvents();
  var c = {'console_x': 0, 'console_y': 0,
           'foreground': 0xffffff, 'background': 0x000000};
  consoleEmitString(c, 'Loading...');
  HTTP.post('/read', {'index': '0'}, afterLoad, null);
}


main();


// -----------------------------------------------------------------


</script>


</body>
</html>

